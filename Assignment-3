from collections.abc import MutableMapping
from random import randrange

class MapBase(MutableMapping):
    
    class _Item:
        __slots__ = '_key', '_value'
        def __init__(self, key, value):
            self._key = key
            self._value = value

        def __eq__(self, other):
            return self._key == other._key  

        def __ne__(self, other):
            return not self == other

        def __lt__(self, other):
            return self._key < other._key

class HashMapBase(MapBase):

    def __init__(self, cap=11, p=109345121):
        """Create an empty hash-table map."""
        self._table = cap * [None]
        self._n = 0                        
        self._prime = p                     
        self._scale = 1 + randrange(p-1)    
        self._shift = randrange(p)          

    def _hash_function(self, k):
        return (hash(k)*self._scale + self._shift) % self._prime % len(self._table)

    def __len__(self):
        return self._n

    def __getitem__(self, k):
        j = self._hash_function(k)
        return self._bucket_getitem(j,k)     

    def __setitem__(self, k, v):
        j = self._hash_function(k)
        self._bucket_setitem(j,k,v)             
        if self._n > len(self._table) // 2:     
            self._resize(2*len(self._table) - 1)

    def __delitem__(self, k):
        j = self._hash_function(k)
        self._bucket_delitem(j,k)               
        self._n -= 1

    def _resize(self, c):                       
        old = list(self.items())            
        self._table = c * [None]               
        self._n = 0                             
        for (k,v) in old:
            self[k] = v

class ProbeHashMap(HashMapBase):
    _AVAIL = object()
    def _is_available(self, j):
        return self._table[j] is None or self._table[j] is ProbeHashMap._AVAIL

    def _find_slot(self, j, k):
        firstAvail = None
        while True:
            if self._is_available(j):
                if firstAvail is None:
                    firstAvail = j                  
                if self._table[j] is None:
                    return (False, firstAvail)      
            elif k == self._table[j]._key:
                return (True, j)                    
            j = (j+1) % len(self._table)            

    def _bucket_getitem(self, j, k):
        found, s = self._find_slot(j, k)
        if not found:
            raise KeyError('Key Error: ' + repr(k)) 
        return self._table[s]._value

    def _bucket_setitem(self, j, k, v):
        found , s = self._find_slot(j, k)
        if not found:
            self._table[s] = self._Item(k,v)        
            self._n += 1                           
        else:
            self._table[s]._value = v               

    def _bucket_delitem(self, j, k):
        found, s = self._find_slot(j, k)
        if not found:
             raise KeyError('Key Error: ' + repr(k))
        self._table[s] == ProbeHashMap._AVAIL       

    def __iter__(self):
        for j in range(len(self._table)):
            if not self._is_available(j):
                yield self._table[j]._key

class SpellChecker:
    
    def _get_the_reference_data(self):
        fp = open(self._reference_word_file, "r")
        nextline = fp.readline()
        while nextline != "":
            nextline = nextline.strip("\n")
            nextline = nextline.strip()
            if len(nextline) >= self._min_length_of_reference_words :
                self._probe_hash_map[nextline] = None
            nextline = fp.readline()
        return self._probe_hash_map

    def _shape_the_string(self, string):
        if string.isalpha() == True :
            string = string.lower()
            return [string]
        elif string.isdecimal() == True or string.isdigit() == True :
            self._flag_0 = 0
            return []
        else:
            for i in range(len(self._Punctuation_Marks)):
                string = string.strip(str(self._Punctuation_Marks[i]))
                if string.isalpha() == True :
                    string = string.lower()
                    return [string]
            Sub_Strings = []
            for i in range(len(self._Punctuation_Marks)):
                list_of_sub_strings = string.split(str(self._Punctuation_Marks[i]))
                for l in range(len(list_of_sub_strings)):
                    if list_of_sub_strings[l].isalpha() == True:
                        list_of_sub_strings[l] = list_of_sub_strings[l].lower()
                        Sub_Strings.append(list_of_sub_strings[l])
            if len(Sub_Strings) == 0 : 
                if string.isidentifier() == False: self._flag_0 = 2
                else: self._flag_0 = 3
            return Sub_Strings        
        
    def _insert_character(self, string):
        L = []
        for i in range(len(string)+1):
            for l in range(len(self._Ascii_Lowercase)):
                Final_Form_of_String = string[0:i] + self._Ascii_Lowercase[l] + string[i:len(string)]
                L.append(Final_Form_of_String)
        return L
    
    def _remove_character(self, string):
        L = []
        for i in range(len(string)):
            Final_Form_of_String = string[0:i] + string[i+1:len(string)]
            L.append(Final_Form_of_String)
        return L      
    
    def _reorder_adjoint_character(self, string):
        L = []
        for i in range(len(string)-1):
            Final_Form_of_String = string[0:i] + string[i+1] + string[i] + string[i+2:len(string)]
            L.append(Final_Form_of_String)
        return L
    
    def _replacing_a_character(self, string):
        L = []
        for i in range(len(string)):
            for l in range(len(self._Ascii_Lowercase)):
                Final_Form_of_String = string[0:i] + self._Ascii_Lowercase[l] + string[i+1:len(string)]
                L.append(Final_Form_of_String)
        return L

    def __init__(self, min_length_of_reference_words = 3, max_number_of_recommendation_words = 3, reference_word_file = "google-10000-english.txt"):
        self._probe_hash_map = ProbeHashMap()
        self._data_base = []
        self._reference_word_file = reference_word_file
        self._Punctuation_Marks = [".",",",":",";","!","?","'","-","\"","(",")","[","]","*","%","+","/"]
        self._Ascii_Lowercase = "abcdefghijklmnopqrstuvwxyz"
        self._max_number_of_recommendation_words = max_number_of_recommendation_words
        self._min_length_of_reference_words = min_length_of_reference_words

    def check(self, The_Input_File):
        self._get_the_reference_data()
        fp_0 = open(The_Input_File, "r")
        fp_1 = open("Feedback.txt","w")
        nextline = fp_0.readline()
        while nextline != "":
            nextline = nextline.strip("\n")
            nextline = nextline.strip()
            nextline = nextline.split()
            for i in range(len(nextline)):
                current_word = nextline[i]
                current_word_list = self._shape_the_string(current_word)
                if len(current_word_list) == 0:
                    if self._flag_0 == 0: 
                        The_Output = current_word + " --> " + "Since it contains only digit(s), No Recommendation" + "\n"
                        fp_1.write(The_Output)
                    elif self._flag_0 == 1:
                        The_Output = current_word + " --> " + "Since it is a merge of digist(s) and letter(s), No Recommendation" + "\n"
                        fp_1.write(The_Output)
                    elif self._flag_0 == 2:
                        The_Output = current_word + " --> " + "Since there is only punctuation mark(s) here, No Recommendation" + "\n"
                        fp_1.write(The_Output)                        
                    elif self._flag_0 == 3:
                        The_Output = current_word + " --> " + "Since it is a merge of different types of characters, No Recommendation" + "\n"
                        fp_1.write(The_Output)                   
                for l in range(len(current_word_list)):
                    flag = 0
                    if len(current_word_list) >= 2: flag = 1
                    if len(current_word_list[l]) + 1 < self._min_length_of_reference_words:
                            The_Output = current_word + " --> " + "Since the length of the word(s) is/are less than the reference words' length, No Recommendation" + "\n"
                            fp_1.write(The_Output)
                    elif current_word_list[l] in self._probe_hash_map :
                        if flag == 0:
                            The_Output = current_word + " --> " + "OK" + "\n"
                            fp_1.write(The_Output)
                        else:
                            The_Output = current_word + " --> " + "OK" + " (for the " + str(l+1) + ". part of the word)" + "\n"
                            fp_1.write(The_Output)
                    else:
                        Count = 0
                        Max_Count = self._max_number_of_recommendation_words
                        The_List_of_Recommendation = []
                        if Count < Max_Count:
                            Removed_List = self._remove_character(current_word_list[l])
                            for n in range(len(Removed_List)):
                                if Count == Max_Count: break
                                if Removed_List[n] in self._probe_hash_map and Removed_List[n] not in The_List_of_Recommendation :
                                    The_List_of_Recommendation.append(Removed_List[n])
                                    Count = Count + 1 
                        if Count < Max_Count:
                            Inserted_List = self._insert_character(current_word_list[l])
                            for m in range(len(Inserted_List)):
                                if Count == Max_Count: break
                                if Inserted_List[m] in self._probe_hash_map and Inserted_List[m] not in The_List_of_Recommendation :
                                    The_List_of_Recommendation.append(Inserted_List[m])
                                    Count = Count + 1
                        if Count < Max_Count:
                            Replaced = self._replacing_a_character(current_word_list[l])
                            for t in range(len(Replaced)):
                                if Count == Max_Count: break
                                if Replaced[t] in self._probe_hash_map and Replaced[t] not in The_List_of_Recommendation :
                                    The_List_of_Recommendation.append(Replaced[t])
                                    Count = Count + 1
                        if Count < Max_Count:
                            Adjoint_Reordered = self._reorder_adjoint_character(current_word_list[l])
                            for p in range(len(Adjoint_Reordered)):
                                if Count == Max_Count: break
                                if Adjoint_Reordered[p] in self._probe_hash_map and Adjoint_Reordered[p] not in The_List_of_Recommendation :
                                    The_List_of_Recommendation.append(Adjoint_Reordered[p])
                                    Count = Count + 1
                        if len(The_List_of_Recommendation) == 0:
                            if flag == 0:
                                The_Output = current_word + " --> " + "No Recommendation" + "\n"
                                fp_1.write(The_Output)
                            else:
                                 The_Output = current_word + " --> " + "No Recommendation" + " (for the " + str(l+1) + ". part of the word)" + "\n"
                                 fp_1.write(The_Output)
                        else:
                            Recommendation = ""
                            for n in range(len(The_List_of_Recommendation)-1):
                                Recommendation += The_List_of_Recommendation[n] + ", "
                            Recommendation += The_List_of_Recommendation[-1]
                            if flag == 0:
                                The_Output = current_word + " --> " + Recommendation + "\n"
                                fp_1.write(The_Output)
                            else:
                                The_Output = current_word + " --> " + Recommendation + " (for the " + str(l+1) + ". part of the word)" + "\n"
                                fp_1.write(The_Output)
       
                            
            nextline = fp_0.readline()
            
        fp_0.close()
        fp_1.close()

Test = SpellChecker()
Test.check("Input.txt")

